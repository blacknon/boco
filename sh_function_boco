#!/bin/bash

# @TODO:
#    ・変数名の見直し！(他の言語と違って混ざりやすい。あまり良い状態とは言えないので。)
#    ・DATAの行数が残りのターミナル行数より多い場合の処理について
#    　・プロンプトが一番上の行にくるよう、出力行数を調整
#    　・上下キーでスクロールさせるようにする(現状は２行前後ずれるため、原因究明して改修)
#    ・カーソルのある行については、行全体の色を変化させるようにANSIカラーコードの出力を修正する
#    ・出力行の検索、絞り込み機能の追加
#    　・headerに機能をつける
#    　・非正規表現での検索機能
#    　・正規表現での検索機能
#    　・Ctrl+Rで切り替えできるようにする
#    ・複数行の選択機能(Tabキー？)
#    ・zshでfunctionとして読み込んでも動作するようにする
#    ・バッファを挟んで、リアルタイムで出力が追加されても対応できるようにする


# @brief:
#     boco
function boco() {
    # @brief: get cursor positon
    # @return: $row $col
    function __get_cursor_position() {
        exec < /dev/tty
        local OLD_STTY=$(stty -g)
        stty raw -echo min 0

        # get position data
        echo -ne "\e[6n" > /dev/tty
        IFS=';' read -r -d R -a POSITION
        stty ${OLD_STTY}

        # parse row and column
        local POS_ROW=${POSITION[0]:2}
        local POS_COL=${POSITION[1]}
        echo ${POS_ROW} ${POS_COL}
    }


    # @brief: print data line with ANSI escape code.
    #     __print_line_position
    #          ${1} ... NOW_PROMPT_POSITION(LINE)
    #          ${2} ... ADD_POSITION(LINE)
    #          ${3} ... CURSOR_LINE_FLAG(0(true)|1(false))
    #          ${4} ... DATA(LINE)
    function __print_line_position() {
        local NOW_POS_ROW="${1}"
        local ADD_POS_ROW="${2}"
        local PRINT_POS_ROW=$((${NOW_POS_ROW} + ${ADD_POS_ROW}))

        # move cursor
        echo -ne "\e["${PRINT_POS_ROW}";0H"

        # print line
        if [ ${3} -eq 0 ];then
            printf "%s\n" "${4}" >&2
        else
            printf "\e[44m%s\n\e[0m" "${4}" >&2
        fi
    }

    # @brief:
    #     __print_data
    #          ${1} ... SEARCH_WORD
    #          ${2} ... VIEW_MAX_LINE
    #          ${3} ... DATA
    function __print_data() {
        # DATA to Array
        local OLD_IFS=${IFS}
        local IFS=$'\n'
        local ARRAY_DATA=($(echo "${3}"))
        local ARRAY_DATA_COUNT=${#ARRAY_DATA[@]}
        local IFS=${OLD_IFS}

        # print header
        echo "NOW_LINE: " "${NOW_LINE}" >&2

        # print line
        for (( i = 0; i < "${2}"; i++ ));
        do
            if [ ${NOW_LINE} -eq ${i} ];then
                __print_line_position "${POS[0]}" "$((${i}+1))" 1 "${ARRAY_DATA[${i}]}"
            else
                __print_line_position "${POS[0]}" "$((${i}+1))" 0 "${ARRAY_DATA[${i}]}"
            fi
        done
    }

    # @brief:
    #     clear printed data
    function __clear_print_data() {
        echo -ne "\e["${POS[0]}";0H" >&2 # move cursor
        echo $'\e[2K' $'\e[1A' >&2
        for ((i = 0; i < ${VIEW_MAX_LINE};i++));
        do
            echo $'\e[1B' >&2
            echo $'\e[1A' $'\e[1G' $'\e[2K' $'\e[1A' >&2
        done
        echo -ne "\e["${POS[0]}";0H" >&2
    }

    # set shopt(windows size)
    shopt -s checkwinsize; (:;:)

    # get data from stdin or file.
    if [ -p /dev/stdin ];then
        local DATA="$(</dev/stdin)"
    else
        local DATA="$(<$@)"
    fi

    # DATA to Array
    local OLD_IFS=${IFS}
    local IFS=$'\n'
    local ARRAY_DATA=($(echo "${DATA}"))
    local ARRAY_DATA_COUNT=${#ARRAY_DATA[@]}
    local IFS=${OLD_IFS}

    # get cursor positon
    local POS=($(__get_cursor_position))

    # set view max line
    local VIEW_MAX_LINE=${#ARRAY_DATA[@]}
    if [[ $((${LINES} - ${POS[0]})) -le $VIEW_MAX_LINE ]];then
        local VIEW_MAX_LINE=$((${LINES} - ${POS[0]}))
    fi
    # echo ${VIEW_MAX_LINE}


    # set NOW_LINE, SELECTED_LINE
    local NOW_LINE=0
    local SELECTED_LINE=(0)

    # set SEARCH_WORD
    local SEARCH_WORD=""

    # first print out
    __print_data "${SEARCH_WORD}" "${VIEW_MAX_LINE}" "${DATA}"

    while true
    do
        # get input key
        # TODO: forking zsh/bash
        read -rsn1 INPUT_KEY </dev/tty

        case "${INPUT_KEY}" in
            # hundling escape
            $'\x1b')
            read -rsn1 -t 0.1 TMP_KEY </dev/tty
            if [[ "${TMP_KEY}" == "[" ]]; then
                read -rsn1 -t 0.1 TMP_KEY </dev/tty
                case "${TMP_KEY}" in
                    # up key
                    "A")
                        local NOW_LINE=$((${NOW_LINE} - 1))
                        if [[ ${NOW_LINE} -le 0 ]];then
                            local NOW_LINE=0
                        fi
                        __clear_print_data
                        __print_data "${SEARCH_WORD}" "${VIEW_MAX_LINE}" "${DATA}"
                        ;;

                    # down key
                    "B")
                        local NOW_LINE=$((${NOW_LINE} + 1))
                        if [[ ${NOW_LINE} -gt $((${VIEW_MAX_LINE} - 1)) ]];then
                            local NOW_LINE=$((${VIEW_MAX_LINE} - 1))
                        fi
                        __clear_print_data
                        __print_data "${SEARCH_WORD}" "${VIEW_MAX_LINE}" "${DATA}"
                        ;;
                esac
            fi

            # Flush "stdin" with 0.1  sec timeout.
            read -rsn5 -t 0.1
            ;;

            # input Enter key
            "")
                __clear_print_data
                echo "${ARRAY_DATA[${NOW_LINE}]}"
                break
                ;;

            *)
                local SEARCH_WORD=${SEARCH_WORD}${INPUT_KEY}
                ;;
        esac
    done

    echo "POSITION_ROW:" ${POS[0]}
    echo "POSITION:" ${LINES}
    echo "VIEW_MAX_LINE:" ${VIEW_MAX_LINE}
}
