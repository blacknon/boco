#!/bin/bash
# @AUTHOR:
#    Blacknon(blacknon@orebibou.com)
# @NOTE:
#    Incremental search tool implemented with Bash function.
# @TODO:
#    ・出力行の検索、絞り込み機能の追加
#    　・正規表現での検索機能
#    　・Ctrl+Rで切り替えできるようにする
#    ・複数行の選択機能(Tabキー)
#    ・行表示の処理を、最低限の画面更新にしてパフォーマンスを改善する
#    ・zshでfunctionとして読み込んでも動作するようにする
#    ・バッファを挟んで、リアルタイムで出力が追加されても対応できるようにする
#    ・上下キーの使用時では、色が変わる行のみ出力し直すことで対処させる

## ----------
# function
## ----------
function boco() {
  ## ----------
  # getopts
  ## ----------
  while getopts p OPT
  do
    case $OPT in
      "p" ) local FLG_P="TRUE" ;;
    esac
  done


  ## ----------
  # shopt/setopt
  ## ----------
  # set shopt(windows size. only bash)
  case "${SHELL##*/}" in
    bash*) shopt -s checkwinsize; (:;:) ;;
    zsh*)  setopt localoptions ksharrays ;;
  esac

  ## ----------
  # variable
  ## ----------
  # ANSI Escape
  local -r ANSI_COLOR_NONE=$'\E[0m'
  local -r ANSI_COLOR_RED=$'\E[0;31m'
  local -r ANSI_COLOR_GREEN=$'\E[0;32m'
  local -r ANSI_COLOR_ORANGE=$'\E[0;33m'
  local -r ANSI_COLOR_BLUE=$'\E[0;34m'
  local -r ANSI_COLOR_PURPLE=$'\E[0;35m'
  local -r ANSI_COLOR_CYAN=$'\E[0;36m'
  local -r ANSI_COLOR_LGRAY=$'\E[0;37m'
  local -r ANSI_COLOR_BACK_RED=$'\E[41m'
  local -r ANSI_COLOR_BACK_GREEN=$'\E[42m'
  local -r ANSI_COLOR_BACK_ORANGE=$'\E[43m'
  local -r ANSI_COLOR_BACK_BLUE=$'\E[44m'
  local -r ANSI_COLOR_BACK_PURPLE=$'\E[45m'
  local -r ANSI_COLOR_BACK_CYAN=$'\E[46m'
  local -r ANSI_COLOR_BACK_GRAY=$'\E[47m'

  local -r ANSI_CURSOR_GET=$'\E[6n'
  local GREP_CLEAR=$'\E[m\E[K'

  # local use variables
  local INPUT_KEY # input key code
  local TMP_KEY # input key code(2nd)
  local DATA # Get stdin or file DATA
  local ARRAY_DATA # Data to Array(Original)
  local VIEW_ARRAY_DATA # Data to Array(Refine Data)
  local NOW_CURSOR # Now cursor position in terminal
  local NOW_CURSOR_LINE # Now cursor position in terminal(line)
  local LIST_NOW_LINE # now cursor line (in boco list)
  local LIST_SELECTED_LINE # now selected line (in boco list. array)
  local MAX_LINE # VIEW_ARRAY_MAX_LINE
  local VIEW_MAX_LINE # max line in terminal
  local LIST_SCROLL_POSITION # boco list scroll position (1st line)
  local SURPLUS_LINE

  # env
  local -r OLD_IFS=${IFS}

  # cmd
  local CMD_GREP

  ## ----------
  # function
  ## ----------

  # @brief:
  #     get now cursor positon in terminal.
  # @return:
  #     NOW_CURSOR_ROW NOW_CURSOR_COLUMN
  function __get_cursor_position() {
    # variable
    local OLD_STTY
    local NOW_CURSOR

    # move tty
    exec < /dev/tty
    OLD_STTY=$(stty -g)
    stty raw -echo min 0

    # get position data
    printf "${ANSI_CURSOR_GET}" > /dev/tty

    case "${SHELL##*/}" in
      bash*) IFS=';' read -r -d R -a CURSOR ;;
      zsh*)  IFS=';' read -s -d R CURSOR ;;
    esac

    IFS=$'\n'
    stty "${OLD_STTY}"

    CURSOR="${CURSOR##*\[}"
    CURSOR="${CURSOR%;*}"

    NOW_CURSOR_LINE=${CURSOR}
  }

  # @brief: print data line with ANSI escape code.
  #     __print_line_position
  #          ${1} ... ADD_LINE
  #          ${2} ... CURSOR_LINE_TYPE(0(Current Line)|1(Selected Line)|2(Other))
  #          ${3} ... PRINT_DATA
  function __print_line_position() {
    # variable
    local ADD_LINE
    local CURSOR_LINE_FLAG
    local PRINT_LINE
    local PRINT_DATA

    ADD_LINE=${1}
    CURSOR_LINE_TYPE=${2}
    PRINT_LINE=$((${NOW_CURSOR_LINE} + ${ADD_LINE}))
    LINE="${3}"
    PRINT_DATA=${LINE#*:}

    # move cursor
    printf "\e["${PRINT_LINE}";0H" >&2

    # print line
    if [[ ${CURSOR_LINE_TYPE} -eq 0 ]];then
      PRINT_DATA="${PRINT_DATA//$(echo ${GREP_CLEAR})/$(echo ${GREP_CLEAR}${ANSI_COLOR_YELLOW}${ANSI_COLOR_BACK_BLUE})}"
      printf "${ANSI_COLOR_YELLOW}${ANSI_COLOR_BACK_BLUE}"'%s'"${ANSI_COLOR_NONE}\n" "${PRINT_DATA}" >&2

    elif [[ ${CURSOR_LINE_TYPE} -eq 1 ]]; then
      PRINT_DATA="${PRINT_DATA//$(echo ${GREP_CLEAR})/$(echo ${GREP_CLEAR}${ANSI_COLOR_YELLOW}${ANSI_COLOR_BACK_GREEN})}"
      printf "${ANSI_COLOR_YELLOW}${ANSI_COLOR_BACK_GREEN}"'%s'"${ANSI_COLOR_NONE}\n" "${PRINT_DATA}" >&2
    else
      printf "%s\n" "${PRINT_DATA}" >&2
    fi
  }

  # @brief:
  #     __print_data
  function __print_data() {
    # variable
    local HEADER_TEXT
    local HEADER_TEXT_COUNT
    local LIST_RANGE_MAX
    local LIST_RANGE_MIN
    local LIST_TEXT

    # move cursor
    printf "\e[${NOW_CURSOR_LINE};0H" >&2

    # print header
    HEADER_TEXT="QUERY: ${SEARCH_WORD} "
    HEADER_TEXT_COUNT=${#HEADER_TEXT}
    printf "${HEADER_TEXT}\n" >&2

    # print line
    LIST_RANGE_MAX=$((${LIST_SCROLL_POSITION} + ${VIEW_MAX_LINE}))

    local x=0
    for ((i=${LIST_SCROLL_POSITION};i<${LIST_RANGE_MAX};i++));
    do
      # テキストを変数に代入
      LIST_LINE="${VIEW_ARRAY_DATA[${i}]}"

      if [[ ${LIST_NOW_LINE} -eq ${i} ]];then
        # print now select line
        __print_line_position $((${x} + 1)) 0 "${LIST_LINE}"
      elif [[ $(__selected_check_in ${LIST_LINE%%:*}) -eq 0 ]]; then
        # print selected line
        __print_line_position $((${x} + 1)) 1 "${LIST_LINE}"
      else
        # print other line
        __print_line_position $((${x} + 1)) 2 "${LIST_LINE}"
      fi
      x=$((${x} + 1 ))
    done

    # cursor move to header
    printf "\e[${NOW_CURSOR_LINE};${HEADER_TEXT_COUNT}H" >&2
  }

  # @brief:
  #     clear printed data
  function __clear_print_data() {
    # move cursor
    printf "\e[${NOW_CURSOR_LINE};0H" >&2

    # clear line
    echo $'\e[2K' $'\e[1A' >&2

    for ((i=0;i<${VIEW_MAX_LINE};i++));
    do
      # move cursor 1 down
      echo $'\e[1B' >&2

      # clear line
      echo $'\e[1A'$'\e[1G'$'\e[2K'$'\e[1A' >&2
    done

    # move cursor
    printf "\e[${NOW_CURSOR_LINE};0H" >&2
  }

  # @brief:
  #     update view array data.
  function __update_view_array_data() {
    case "${SHELL##*/}" in
      bash*) shopt -s checkwinsize; (:;:) ;;
      zsh*)  setopt localoptions ksharrays ;;
    esac
    local SEARCH_WORD_COUNT
    local ARRAY_STR
    local VIEW_ARRAY_STR
    local SEARCH_WORD_ARRAY
    local FOR_COUNT

    local IFS=$'\n'
    SEARCH_WORD_COUNT=${#SEARCH_WORD}

    # clear VIEW_ARRAY_DATA
    VIEW_ARRAY_DATA=()
    ARRAY_STR="$(IFS=$'\n';echo "${ARRAY_DATA[*]}")"

    # grep DATA
    if [[ ${SEARCH_WORD_COUNT} -gt 0 ]];then
      # split string at space
      case "${SHELL##*/}" in
        bash*) IFS=" " read -r -a SEARCH_WORD_ARRAY <<< "${SEARCH_WORD}" ;;
        zsh*)  IFS=" " read -r -A SEARCH_WORD_ARRAY <<< "${SEARCH_WORD}" ;;
      esac

      IFS=$'\n'
      VIEW_ARRAY_STR="${ARRAY_STR}"

      FOR_COUNT=0
      for WORD in ${SEARCH_WORD_ARRAY[*]}; do
        if [[ ${FOR_COUNT} -eq 0 ]];then
          # with number
          VIEW_ARRAY_STR="$(echo "${VIEW_ARRAY_STR}" | GREP_COLORS='ln=:se=' \grep -a -F -n --color=always -i -- ${WORD})"
        else
          # without number
          VIEW_ARRAY_STR="$(echo "${VIEW_ARRAY_STR}" | GREP_COLORS='ln=:se=' \grep -a -F --color=always -i -- ${WORD})"
        fi
        FOR_COUNT=$((FOR_COUNT + 1))
      done
    else
      # use regex
      VIEW_ARRAY_STR="$(echo "${ARRAY_STR}" | GREP_COLORS='ln=:se=' \grep -a -n -E '.*')"
    fi

    # set VIEW_ARRAY_DATA
    VIEW_ARRAY_DATA=($(echo "${VIEW_ARRAY_STR}"))
    local IFS=${OLD_IFS}
  }

  # @brief: update MAX_LINE
  function __update_max_line() {
    # set MAX_LINE
    MAX_LINE="${#VIEW_ARRAY_DATA[@]}"
    VIEW_MAX_LINE=${MAX_LINE}

    SURPLUS_LINE=$((${TERMINAL_LINES} - ${NOW_CURSOR_LINE}))

    # if [ SURPLUS_LINE <= (TERMINAL_LINES/2) ]
    if [[ ${SURPLUS_LINE} -le $((${TERMINAL_LINES} / 2)) ]];then
      SURPLUS_LINE=$((${TERMINAL_LINES} / 2))
    fi

    # if [ SURPLUS_LINE <= MAX_LINE ]
    if [[ ${SURPLUS_LINE} -le ${VIEW_MAX_LINE} ]];then
      VIEW_MAX_LINE="${SURPLUS_LINE}"
    fi

    # if [ $((${TERMINAL_LINES} - ${MAX_LINE})) <= NOW_CURSOR_LINE ]
    if [[ $((${TERMINAL_LINES} - ${VIEW_MAX_LINE})) -le ${NOW_CURSOR_LINE} ]];then
      NOW_CURSOR_LINE=$((${TERMINAL_LINES} - ${VIEW_MAX_LINE}))
    fi

    if [[ ${MAX_LINE} -le ${LIST_SCROLL_POSITION} ]];then
      LIST_SCROLL_POSITION=$((${MAX_LINE} - 1))

      if [[ ${LIST_SCROLL_POSITION} -lt 0 ]];then
        LIST_SCROLL_POSITION=0
      fi
    fi

    if [[ ${LIST_NOW_LINE} -ge $((${VIEW_MAX_LINE})) ]];then
      LIST_NOW_LINE=$((${VIEW_MAX_LINE} - 1))
    fi

    for ((i=0;i<${VIEW_MAX_LINE};i++)) {
      echo "" >&2
    }

    printf "\e[${NOW_CURSOR_LINE};0H" >&2
  }

  # @brief: scroll up function
  function __scroll_up() {
    LIST_NOW_LINE=$((${LIST_NOW_LINE} - 1))
    if [[ ${LIST_NOW_LINE} -lt 0 ]];then
      LIST_NOW_LINE=0
      return
    fi

    # scroll up
    LIST_RANGE_MIN=${LIST_SCROLL_POSITION}
    if [[ ${LIST_NOW_LINE} -lt ${LIST_RANGE_MIN} ]];then
      # if scroll up
      LIST_SCROLL_POSITION=$((${LIST_SCROLL_POSITION} - 1))

      if [[ ${LIST_SCROLL_POSITION} -lt 0 ]];then
        LIST_SCROLL_POSITION=0
      fi

      __clear_print_data
      __print_data

    else
      local HEADER_TEXT
      local HEADER_TEXT_COUNT
      local TERM_LINE
      local UNSELECT_LINE

      HEADER_TEXT="QUERY: ${SEARCH_WORD} "
      HEADER_TEXT_COUNT=${#HEADER_TEXT}

      TERM_LINE=$((${LIST_NOW_LINE} - ${LIST_SCROLL_POSITION}))

      # unselect line
      UNSELECT_LINE="${VIEW_ARRAY_DATA[$((${LIST_NOW_LINE} + 1))]}"
      if [[ $(__selected_check_in ${UNSELECT_LINE%%:*}) -eq 0 ]];then
        __print_line_position $((${TERM_LINE} + 2)) 1 "${VIEW_ARRAY_DATA[$((${LIST_NOW_LINE} + 1))]}"
      else
        __print_line_position $((${TERM_LINE} + 2)) 2 "${VIEW_ARRAY_DATA[$((${LIST_NOW_LINE} + 1))]}"
      fi

      # select line
      __print_line_position $((${TERM_LINE} + 1)) 0 "${VIEW_ARRAY_DATA[${LIST_NOW_LINE}]}"

      # move cursor
      printf "\e[${NOW_CURSOR_LINE};${HEADER_TEXT_COUNT}H" >&2
    fi
  }

  # @brief: scroll down function
  function __scroll_down() {
    LIST_NOW_LINE=$((${LIST_NOW_LINE} + 1))
    if [[ ${LIST_NOW_LINE} -gt $((${MAX_LINE} - 1)) ]];then
      LIST_NOW_LINE=$((${MAX_LINE} - 1))
      return
    fi

    # scroll down
    local LIST_RANGE_MAX=$((${LIST_SCROLL_POSITION} + ${VIEW_MAX_LINE}))
    if [[ ${LIST_NOW_LINE} -ge ${LIST_RANGE_MAX} ]];then
      # if scroll down
      LIST_SCROLL_POSITION=$((${LIST_SCROLL_POSITION} + 1))
      __clear_print_data
      __print_data
    else
      local HEADER_TEXT
      local HEADER_TEXT_COUNT
      local TERM_LINE
      local UNSELECT_LINE

      HEADER_TEXT="QUERY: ${SEARCH_WORD} "
      HEADER_TEXT_COUNT=${#HEADER_TEXT}

      TERM_LINE=$((${LIST_NOW_LINE} - ${LIST_SCROLL_POSITION}))
      UNSELECT_LINE="${VIEW_ARRAY_DATA[$((${LIST_NOW_LINE} - 1))]}"

      # unselect line
      if [[ $(__selected_check_in ${UNSELECT_LINE%%:*}) -eq 0 ]];then
        __print_line_position ${TERM_LINE} 1 "${VIEW_ARRAY_DATA[$((${LIST_NOW_LINE} - 1))]}"
      else
        __print_line_position ${TERM_LINE} 2 "${VIEW_ARRAY_DATA[$((${LIST_NOW_LINE} - 1))]}"
      fi

      # select line
      __print_line_position "$((${TERM_LINE} + 1))" 0 "${VIEW_ARRAY_DATA[${LIST_NOW_LINE}]}"

      # move cursor
      printf "\e[${NOW_CURSOR_LINE};${HEADER_TEXT_COUNT}H" >&2
    fi
  }

  # @brief: trap ctrl + c
  function __trap_2() {
    __clear_print_data
    local IFS=${OLD_IFS}
    exit 1
  }

  # @brief:
  #     check if number is included in array
  function __selected_check_in() {
    for e in ${LIST_SELECTED_LINE[@]}; do
      if [[ ${e} -eq ${1} ]];then
        echo 0
        return
      fi
    done

    echo 1
  }

  # @brief: Add element to LIST_SELECTED_LINE
  function __selected_add() {
    LIST_SELECTED_LINE=(${LIST_SELECTED_LINE[@]} $1)
  }

  # @brief: Delete element to LIST_SELECTED_LINE
  function __selected_del() {
    local NEW_LIST_SELECTED_LINE=()
    for e in ${LIST_SELECTED_LINE[@]}; do
      if [[ ! ${e} -eq ${1} ]];then
        NEW_LIST_SELECTED_LINE=(${NEW_LIST_SELECTED_LINE[@]} ${e})
      fi
    done

    LIST_SELECTED_LINE=(${NEW_LIST_SELECTED_LINE[@]})
  }


  ## ----------
  # main
  ## ----------
  # set trap
  trap __trap_2 2

  # check -p option
  if [[ "${FLG_P}" != "TRUE" ]];then
    printf '\033[?7l'
  fi

  # get data from stdin or file.
  if [ -p /dev/stdin ];then
    DATA="$(</dev/stdin)"
  else
    DATA="$(<$@)"
  fi

  # DATA to Array
  local IFS=$'\n'
  local ARRAY_DATA=($(echo "${DATA}"))
  local IFS=${OLD_IFS}

  # get cursor positon
  __get_cursor_position

  # get terminal size
  local TERMINAL_LINES=$((${LINES} - 1))
  local TERMINAL_COLUMNS=$((${COLUMNS} - 1))

  # update VIEW_ARRAY_DATA
  __update_view_array_data

  # set MAX_LINE & VIEW_MAX_LINE
  __update_max_line

  # set LIST_NOW_LINE, LIST_SELECTED_LINE
  LIST_NOW_LINE=0
  LIST_SCROLL_POSITION=0
  LIST_SELECTED_LINE=()

  # set SEARCH_WORD
  local SEARCH_WORD=""

  # first print out
  __print_data

  # get input key loop
  local IFS=$'\n'
  while true
  do
    # get input key
    case "${SHELL##*/}" in
      bash*) read -rsn1 INPUT_KEY </dev/tty ;;
      zsh*)  read -r -s -k 1 INPUT_KEY </dev/tty ;;
    esac

    case "${INPUT_KEY}" in
      # hundling Escape(\x1B)
      $'\x1B')
        case "${SHELL##*/}" in
          bash*) read -rsn1 -t 0.1 TMP_KEY </dev/tty ;;
          zsh*)  read -r -s -k 1 -t 0.1 TMP_KEY </dev/tty ;;
        esac

        if [[ "${TMP_KEY}" == "[" ]]; then
          case "${SHELL##*/}" in
            bash*) read -rsn1 -t 0.1 TMP_KEY </dev/tty ;;
            zsh*)  read -r -s -k 1 -t 0.1 TMP_KEY </dev/tty ;;
          esac

          case "${TMP_KEY}" in
            # up key
            "A") __scroll_up ;;
            # down key
            "B") __scroll_down ;;
          esac
        fi

        # Flush "stdin" with 0.1  sec timeout.
        case "${SHELL##*/}" in
          bash*) read -r -n 5 -t 0.1 ;;
          zsh*)  read -r -k 5 -t 0.1 ;;
        esac

        ;;

      # Delete(Backspace(\x7F)) key
      $'\x7F')
        # get search word count
        local SEARCH_WORD_COUNT=${#SEARCH_WORD}

        # 検索ワードの文字数が0より大きい場合、文字を削除して表示を更新する
        if [[ ${SEARCH_WORD_COUNT} -gt 0 ]];then
          local SEARCH_WORD_COUNT=$((${SEARCH_WORD_COUNT} - 1))
          local SEARCH_WORD=${SEARCH_WORD:0:${SEARCH_WORD_COUNT}}

          __update_view_array_data
          __clear_print_data
          __update_max_line
          __print_data
        fi
        ;;

      # input Space Key
      " ")
        SEARCH_WORD=${SEARCH_WORD}${INPUT_KEY}
        __update_view_array_data
        __clear_print_data
        __update_max_line
        __print_data
        ;;

      # input Tab key(\x09)
      # Toggle multi select.
      $'\x09')
        # add selected line
        local LINE="${VIEW_ARRAY_DATA[${LIST_NOW_LINE}]}"
        if [[ $(__selected_check_in ${LINE%%:*} ) -eq 0 ]];then
          __selected_del ${LINE%%:*}
        else
          __selected_add ${LINE%%:*}
        fi
        __clear_print_data
        __update_max_line
        __print_data
        ;;


      # input Ctrl + A key
      # Selected all view lines.

      # input Ctrl + R key
      # Toggle grep mode(plane <-> regex).
      # $'\cr')
      #   __clear_print_data
      #   echo "Ctrl + R"
      #   break
      #   ;;

      # input Enter key
      ""|$'\n')
        __clear_print_data
        local NEW_LIST_SELECTED_LINE

        if [[ ${#LIST_SELECTED_LINE} -eq 0 ]];then
          local LINE="${VIEW_ARRAY_DATA[${LIST_NOW_LINE}]}"
          LIST_SELECTED_LINE=(${LINE%%:*})
        fi

        IFS=$'\n' NEW_LIST_SELECTED_LINE=($(sort -n <<<"${LIST_SELECTED_LINE[*]}"))
        for NO in ${NEW_LIST_SELECTED_LINE[@]};
        do
          echo "${ARRAY_DATA[$((${NO} - 1))]}"
        done
        break
        ;;

      # other key
      *)
        SEARCH_WORD=${SEARCH_WORD}${INPUT_KEY}
        __update_view_array_data
        __clear_print_data
        __update_max_line
        __print_data
        ;;
    esac
  done

  # check -p option
  if [[ "${FLG_P}" != "TRUE" ]];then
    printf '\033[?7h'
  fi

  local IFS=${OLD_IFS}
}
