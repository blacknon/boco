#!/bin/bash
# @AUTHOR: Blacknon(blacknon@orebibou.com)
# @NOTE:
#    note.
# @TODO:
#    ・変数名の見直し！(他の言語と違って混ざりやすい。あまり良い状態とは言えないので。)
#    ・DATAの行数が残りのターミナル行数より多い場合の処理について
#    　・プロンプトが一番上の行にくるよう、出力行数を調整
#    　・上下キーでスクロールさせるようにする(現状は２行前後ずれるため、原因究明して改修)
#    ・カーソルのある行については、行全体の色を変化させるようにANSIカラーコードの出力を修正する
#    ・出力行の検索、絞り込み機能の追加
#    　・headerに機能をつける
#    　・非正規表現での検索機能
#    　・正規表現での検索機能
#    　・Ctrl+Rで切り替えできるようにする
#    ・複数行の選択機能(Tabキー？)
#    ・zshでfunctionとして読み込んでも動作するようにする
#    ・バッファを挟んで、リアルタイムで出力が追加されても対応できるようにする
#    ・上下キーの使用時では、色が変わる行のみ出力し直すことで対処させる

## ----------
# function
## ----------
function boco() {
  ## ----------
  # shopt
  ## ----------
  # set shopt(windows size)
  shopt -s checkwinsize; (:;:)


  ## ----------
  # variable
  ## ----------
  # ANSI Escape
  local -r ANSI_COLOR_NONE=$'\E[0m'
  local -r ANSI_COLOR_RED=$'\E[0;31m'
  local -r ANSI_COLOR_GREEN=$'\E[0;32m'
  local -r ANSI_COLOR_ORANGE=$'\E[0;33m'
  local -r ANSI_COLOR_BLUE=$'\E[0;34m'
  local -r ANSI_COLOR_PURPLE=$'\E[0;35m'
  local -r ANSI_COLOR_CYAN=$'\E[0;36m'
  local -r ANSI_COLOR_LGRAY=$'\E[0;37m'
  local -r ANSI_COLOR_BACK_RED=$'\E[41m'
  local -r ANSI_COLOR_BACK_GREEN=$'\E[42m'
  local -r ANSI_COLOR_BACK_ORANGE=$'\E[43m'
  local -r ANSI_COLOR_BACK_BLUE=$'\E[44m'
  local -r ANSI_COLOR_BACK_PURPLE=$'\E[45m'
  local -r ANSI_COLOR_BACK_CYAN=$'\E[46m'
  local -r ANSI_COLOR_BACK_GRAY=$'\E[47m'

  local -r ANSI_CURSOR_GET=$'\E[6n'

  # local use variables
  local INPUT_KEY # input key code
  local TMP_KEY # input key code(2nd)
  local DATA # Get stdin or file DATA
  local ARRAY_DATA # Data to Array(Original)
  local VIEW_ARRAY_DATA # Data to Array(Refine Data)
  local NOW_CURSOR # Now cursor position in terminal
  local NOW_CURSOR_LINE # Now cursor position in terminal(line)
  local LIST_NOW_LINE # now cursor line (in boco list)
  local LIST_SELECTED_LINE # now selected line (in boco list. array)
  local MAX_LINE # boco list max line (in terminal)
  local LIST_SCROLL_POSITION # boco list scroll position (1st line)

  # env
  local -r OLD_IFS=${IFS}

  ## ----------
  # function
  ## ----------

  # @brief:
  #     get now cursor positon in terminal.
  # @return:
  #     NOW_CURSOR_ROW NOW_CURSOR_COLUMN
  function __get_cursor_position() {
    # variable
    local OLD_STTY
    local NOW_CURSOR

    # move tty
    exec < /dev/tty
    OLD_STTY=$(stty -g)
    stty raw -echo min 0

    # get position data
    printf "${ANSI_CURSOR_GET}" > /dev/tty
    IFS=';' read -r -d R -a CURSOR
    stty "${OLD_STTY}"

    # parse row, column
    local NOW_CURSOR_ROW="${CURSOR[0]:2}"
    local NOW_CURSOR_COLUMN="${CURSOR[1]}"
    echo "${NOW_CURSOR_ROW}" "${NOW_CURSOR_COLUMN}"
  }

  # @brief: print data line with ANSI escape code.
  #     __print_line_position
  #          ${1} ... ADD_LINE
  #          ${2} ... CURSOR_LINE_FLAG(0(true)|1(false))
  #          ${3} ... SELECTED_LINE_FLAG(0(true)|1(false))
  #          ${4} ... PRINT_DATA
  function __print_line_position() {
    # variable
    local ADD_LINE
    local CURSOR_LINE_FLAG
    local PRINT_LINE
    local PRINT_DATA

    ADD_LINE="${1}"
    CURSOR_LINE_FLAG="${2}"
    PRINT_LINE=$(("${NOW_CURSOR_LINE}" + "${ADD_LINE}"))
    SELECTED_LINE_FLAG="${3}"
    PRINT_DATA=${4}

    # move cursor
    printf "\e["${PRINT_LINE}";0H" >&2

    # print line
    if [ "${CURSOR_LINE_FLAG}" -eq 0 ];then
      printf "%s\n" "${PRINT_DATA}" >&2
    else
      printf "${ANSI_COLOR_YELLOW}${ANSI_COLOR_BACK_BLUE}%s\n${ANSI_COLOR_NONE}" "${PRINT_DATA}" >&2
    fi
  }

  # @brief:
  #     __print_data
  function __print_data() {
    # variable
    local HEADER_TEXT
    local HEADER_TEXT_COUNT
    local LIST_RANGE_MAX
    local LIST_RANGE_MIN

    # move cursor
    printf "\e[${NOW_CURSOR_LINE};0H" >&2

    # print header
    HEADER_TEXT="QUERY: ${SEARCH_WORD} "
    HEADER_TEXT_COUNT=${#HEADER_TEXT}
    printf "${HEADER_TEXT}\n" >&2

    # print line
    LIST_RANGE_MIN="${LIST_SCROLL_POSITION}"
    LIST_RANGE_MAX=$(("${LIST_RANGE_MIN}" + "${MAX_LINE}"))

    for (( i = "${LIST_RANGE_MIN}"; i < "${LIST_RANGE_MAX}"; i++ ));
    do
      if [ ${LIST_NOW_LINE} -eq ${i} ];then
        __print_line_position "$((${i}+1))" 1 0 "${VIEW_ARRAY_DATA[${i}]}"
      else
        __print_line_position "$((${i}+1))" 0 0 "${VIEW_ARRAY_DATA[${i}]}"
      fi
    done

    # cursor move to header
    printf "\e[${NOW_CURSOR_LINE};${HEADER_TEXT_COUNT}H" >&2
  }

  # @brief:
  #     clear printed data
  function __clear_print_data() {
    # move cursor
    printf "\e[${NOW_CURSOR_LINE};0H" >&2

    # clear line
    echo $'\e[2K' $'\e[1A' >&2

    for ((i = 0; i < "${MAX_LINE}"; i++));
    do
      # move cursor 1 down
      echo $'\e[1B' >&2

      # clear line
      echo $'\e[1A' $'\e[1G' $'\e[2K' $'\e[1A' >&2
    done

    # move cursor
    printf "\e[${NOW_CURSOR_LINE};0H" >&2
  }

  # @brief:
  #     update view array data.
  function __update_view_array_data() {
    local IFS=$'\n'
    local SEARCH_WORD_COUNT=${#SEARCH_WORD}

    if [[ ${SEARCH_WORD_COUNT} -gt 0 ]];then
      VIEW_ARRAY_DATA=()
      for ((i = 0; i < "${#ARRAY_DATA}"; i++));
      do
        DATA_ELEMENT="${ARRAY_DATA[$i]}"
        if [[ "${DATA_ELEMENT,,}" == *"${SEARCH_WORD}"* ]];then
          VIEW_ARRAY_DATA=(${VIEW_ARRAY_DATA[@]} "${DATA_ELEMENT}")
        fi
      done
    else
      VIEW_ARRAY_DATA=(${ARRAY_DATA[@]})
    fi

    local IFS=${OLD_IFS}
  }

  function __update_max_line() {
    # set MAX_LINE
    MAX_LINE="${#VIEW_ARRAY_DATA[@]}"

    SURPLUS_LINE=$((${TERMINAL_LINES} - ${NOW_CURSOR_LINE}))
    # if [ TERMINAL_LINES < MAX_LINE ]
    if [[ "${SURPLUS_LINE}" -le "${MAX_LINE}" ]];then
      MAX_LINE="${SURPLUS_LINE}"
    fi

    if [[ ${LIST_NOW_LINE} -gt $((${MAX_LINE})) ]];then
      local LIST_NOW_LINE=$((${MAX_LINE}))
    fi

    # MAX_LINE="$((${MAX_LINE} - 1))"
  }

  # @brief: trap ctrl + c
  function __trap_2() {
    __clear_print_data
    exit 1
  }


  ## ----------
  # main
  ## ----------
  # set trap
  trap __trap_2 2

  # get data from stdin or file.
  if [ -p /dev/stdin ];then
    DATA="$(</dev/stdin)"
  else
    DATA="$(<$@)"
  fi

  # DATA to Array
  local IFS=$'\n'
  local ARRAY_DATA=($(echo "${DATA}"))
  local VIEW_ARRAY_DATA=(${ARRAY_DATA[@]})
  local IFS=${OLD_IFS}

  # get cursor positon
  NOW_CURSOR=($(__get_cursor_position))
  NOW_CURSOR_LINE=${NOW_CURSOR[0]}
  NOW_CURSOR_COLUMN=${NOW_CURSOR[1]}

  # get terminal size
  local TERMINAL_LINES=$(("${LINES}" - 1))
  local TERMINAL_COLUMNS=$(("${COLUMNS}" - 1))

  # set MAX_LINE
  __update_max_line

  # set LIST_NOW_LINE, LIST_SELECTED_LINE
  local LIST_NOW_LINE=0
  local LIST_SCROLL_POSITION=0
  local LIST_SELECTED_LINE=(0)

  # set SEARCH_WORD
  local SEARCH_WORD=""

  # first print out
  __print_data

  # get input key loop
  while true
  do
    # get input key
    # TODO: forking zsh/bash
    read -rsn1 INPUT_KEY </dev/tty

    case "${INPUT_KEY}" in
      # hundling escape
      $'\x1b')
      read -rsn1 -t 0.1 TMP_KEY </dev/tty
      if [[ "${TMP_KEY}" == "[" ]]; then
        read -rsn1 -t 0.1 TMP_KEY </dev/tty
        case "${TMP_KEY}" in
          # up key
          "A")
            local LIST_NOW_LINE=$((${LIST_NOW_LINE} - 1))
            if [[ ${LIST_NOW_LINE} -le 0 ]];then
              local LIST_NOW_LINE=0
            fi
            __clear_print_data
            __print_data
            ;;

          # down key
          "B")
            local LIST_NOW_LINE=$((${LIST_NOW_LINE} + 1))
            if [[ "${LIST_NOW_LINE}" -gt $(("${MAX_LINE}" - 1)) ]];then
              local LIST_NOW_LINE=$(("${MAX_LINE}" - 1))
            fi
            __clear_print_data
            __print_data
            ;;
        esac
      fi

      # Flush "stdin" with 0.1  sec timeout.
      read -rsn5 -t 0.1
      ;;

      # Delete(Backspace) key
      $'\x7F')
        # get search word count
        local SEARCH_WORD_COUNT=${#SEARCH_WORD}

        # 検索ワードの文字数が0より大きい場合、文字を削除して表示を更新する
        if [[ "${SEARCH_WORD_COUNT}" -gt 0 ]];then
          local SEARCH_WORD_COUNT=$(("${SEARCH_WORD_COUNT}" - 1))
          local SEARCH_WORD=${SEARCH_WORD::${SEARCH_WORD_COUNT}}
          __update_view_array_data
          __clear_print_data
          __update_max_line
          __print_data
        fi
        ;;

      # input Enter key
      "")
        __clear_print_data
        echo "${VIEW_ARRAY_DATA[${LIST_NOW_LINE}]}"
        break
        ;;

      # other key
      *)
        SEARCH_WORD=${SEARCH_WORD}${INPUT_KEY}
        __update_view_array_data
        __clear_print_data
        __update_max_line
        __print_data
        ;;
    esac
  done
}
